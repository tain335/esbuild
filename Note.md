# 插件机制
Plugin
>> PluginBuild
>> pluginImpl
	|_ plugin
		|_ onStart // 回调数组
		|_ OnResolve // 回调数组
		|_ OnLoad // 回调数组

# fs模块
增加fs模块抹平平台差异，也可以方便测试

# 打包过程
bundle.ScanBundle
	1.开启协程并行执行插件OnStart回调
	2. 创建scanner, scanner的第一个result永远是runtime解释的结果
	3. 开启一个协程解释runtime
	4. 调用scanner的preprocessInjectedFiles，处理注入的文件代码
	5. 调用addEntryPoints，处理入口
		5.1 获取entry文件resolve后的路径（中间会执行resolve插件方法）
		5.2 执行scanner的maybeParseFile方法
		如果已经解释过就不再解释直接返回解释的结果索引
		// bundler.parseFile
		5.3 新建一个协程执行parseFile方法 然后返回一个sourceIndex
		5.4 执行load插件方法 // 也就是load插件方法是并行的
		5.5 生成一个parseResult结构，包括source路径，对应的loader，是否包含副作用
		5.6 根据对应的loader来执行
		5.7 调用JSCache.Parse方法，最终交给js_parser.Parse来解析代码，如果cache存在且内容没有变化，就直接返回ast（也就是有两层cache, resolve（是有没有访问过）和parse（内容有没有变化））
		生成的ast是没有代码类型信息的
		5.8 如果是ModeBundle模式，会把importRecords遍历然后RunOnResolvePlugins 赋值给 result.resolveResults
		// 只是resolve怎么到解释
		5.9 scaner.resultChannel 会接收所有parseResult; parseResult.resolveResults 是当前文件所有import后resolve的结果，
		result.file.inputFile.Repr.ImportRecords()所有导入的结果
		最终返回的是entryMetas，EntryMeta包含 三个属性
		OutputPath
		SourceIndex
		OutputPathWasAutoGenerated
	6. scanner.scanAllDependencies // 这个阶段就已经解析了js/css
		6.1 不停从scanner.resultChannel获取解析的结果
		6.2 根据result.file.inputFile.Repr.ImportRecords，然后继续调用scanner.maybeParseFile，并更新ImportRecord.SourceIndex, 并不停递归
		6.3 scanner.results接收所有结果
	Bundle.files 等同于 Scanner.results, Scanner.results一开始只有入口文件结果，经过scanAllDependencies，就会拥有所有解析文件的结果
	Scanner.results -> ParseReuslt.resolveResult -> file
	7. processScannedFiles
		迭代scanner.results，检查所有result是否有效，增加一些额外信息
// export default没办法做到精确的tree shake
bundle.Compile // 这个阶段是把所有模块链接在一起，并且输出到文件
	exportsKind 在解释过程中就会根据文件代码里面是否存在exports.xxx = xxx或者module.exports = 'xxx'来获得初始的ExportsKind是CommonJS的方式还是ESM方式
	link阶段
	1.首先从模块导入导出方式，搞清楚模块封装方式，cjs还是esm
	 这是根据模块导入的方式和自身导出的方式决定的
		1. import * as xxx from 'module'
		或者 import defaultVal from 'module'
		但是模块导出方式未定义，则使用cjs方式

		2. require方式导入
			如果模块导出方式已经决定是esm，则默认就是esm模块方式
			否则就是cjs

		3. 动态导入的方式
			如果模块导出方式已经决定是esm，则默认就是esm模块方式
			否则就是cjs

		所以总的来说还是以模块导出的方式来主决定模块封装方式
	2. 因为export * from 'xxx'是会传染的，得再一遍遍历所有文件确定所有模块封装方式和导出方式，导出方式ExportsESM改为ExportsESMWithDynamicFallback
	3. 主要针对export * from 'xxx'，收集所有导出的属性resolvedExports；
	 如果是ExportsCommonJS类型就跳过不收集，因为无法静态分析，所以做不到treeshake
	 LazyExport是加载非js文件标记的；还有找到所有因为export * from 'xxx'，可能导致的歧义

	4. 检查所有import是否都找到匹配

	5. 为每个commonjs文件创建一个namespace，包括import *语法的情况, 确定各个part之间的依赖关系
	这里是使用go协程并发处理

	6.


# 文件监听
采用轮询（因为文件io是阻塞的，轮询是正常操作） 间隔100ms

从scan阶段，就获取所有路径下文件或者目录的状态，然后放到fs.WatchData上里面的结构是map[string]func() string的结构，每隔100ms,执行tryToFindDirtyPath 会去遍历这个map，然后执行func，func会里面判断这个路径跟之前状态都没有变化，如果有就返回dirty的路径

但是并不是每次都是完全遍历完整的map，分批遍历，最多20批，每批最少64个路径，也就是最多要2秒多时间就可以检测出dirty路径然后执行编译
还有一个优化手段就是
利用一个最近修改列表，作为快速遍历，每次先遍历最近修改列表，查看有没有文件变动，如果没有再遍历全部，避免每次遍历全文件列表

# js解释过程
分两遍
1. parse阶段 // 解释转换ast，然后传家scope tree 和 symbols
2. visit阶段 // 绑定identifiers，常量折叠，转化lower target的语法

在appendPart进行visit阶段

scope 里面top level var声明都要移动到top scope上
而原本的声明会变成赋值语句

创建symbol，要把创建的symbol添加到parser的symbols

symbol 和 identifier区别
identifier在词法都是一个标识符，但是解释阶段都会关联为symbol，所以解释过程中要看上下文来决定要不要创建symbol

## 关键结构
type Ref struct {
	SourceIndex uint32
	InnerIndex  uint32
}
// 因为每个goroutine,都会生成一个Symbol，为了给每个Symbol都有一个id，所以有两个字段，一个是文件index，一个是inner index自动递增的id

runtime sourceIndex永远是0


## 一些术语
//   a?.b.c  // EDot
//   a?.b[c] // EIndex
//   a?.b()  // ECall

Lower是指语法从高级的语法编译成更低级的

## 一些解析关键方法
generateImportStmt

解析的时候遇到需要runtime的方法，就会调用callRuntime，把需要依赖的方法记录

最后生成对应import语句
然后会把runtime加入到打包的parts上

import语句
SImport只有ImportRecordIndex索引
所以不需要遍历ast树
直接可以修改import路径


## 名称压缩算法
第一步统计所有字符使用频率，但是减去注释， 符号，导入路径等字符的频率，然后根据使用频率从高到低排序（主要可以提高压缩比，因为都是尽量使用的都是即将重命名的字符串以外的字符）

第二步根据输入的数字（一般是上下文符号的顺序）然后进行因式分解挑选对应的字符就可以挑出最短的字符

###############################################

# 结构
AST {
	// 模块信息，模块源代码
	ModuleTypeData ModuleTypeData
	// 语法树
	Parts          []Part
	// 符号数组，用于后面压缩名称；有几种符号类型：
	SymbolUnbound 一般就是全局变量
	SymbolHoisted
	SymbolHoistedFunction
	SymbolCatchIdentifier
	SymbolGeneratorOrAsyncFunction
	SymbolArguments
	SymbolClass
	SymbolPrivateField
	SymbolPrivateMethod
	SymbolPrivateGet
	SymbolPrivateSet
	SymbolPrivateGetSetPair
	SymbolPrivateStaticField
	SymbolPrivateStaticMethod
	SymbolPrivateStaticGet
	SymbolPrivateStaticSet
	SymbolPrivateStaticGetSetPair
	SymbolLabel
	SymbolTSEnum
	SymbolTSNamespace
	SymbolImport
	SymbolConst
	SymbolInjected
	SymbolOther


	Symbols        []Symbol
	// 模块的作用域, 好几种作用域，ScopeBlock，ScopeWith ，ScopeLabel，ScopeClassName，ScopeClassBody， ScopeCatchBinding，ScopeEntry， ScopeFunctionArgs，ScopeFunctionBody，ScopeClassStaticInit
	要是作用域里包含eval，所有从要父作用域一直到该作用域都要保留名称
	ModuleScope    *Scope
	// 字符频率统计，也用于后面压缩名称
	CharFreq       *CharFreq
	// "#!/usr/bin/env node"
	Hashbang  string
	// 类似 "use strict"
	Directive string
	URLForCSS string
	// 所有parts的top level符号
	TopLevelSymbolToPartsFromParser map[Ref][]uint32

	TSEnums map[Ref]map[string]TSEnumValue
	// 模块导入的信息
	ImportRecords []ast.ImportRecord
	NamedImports            map[Ref]NamedImport
	NamedExports            map[string]NamedExport
	ExportStarImportRecords []uint32

	SourceMapComment logger.Span

	ExportsRef Ref
	ModuleRef  Ref
	WrapperRef Ref

	ApproximateLineCount  int32
	NestedScopeSlotCounts SlotCounts
	HasLazyExport         bool

	UsesExportsRef bool
	UsesModuleRef  bool
	ExportsKind    ExportsKind
}

type Part {
	Stmts  []Stmt // 实际的语句
	Scopes []*Scope // 作用域树
	ImportRecordIndices []uint32 // parser阶段统计的导入包括import和require
	DeclaredSymbols []DeclaredSymbol // 声明列表，可能有重复的声明，因为var的存在
	SymbolUses map[Ref]SymbolUse // 符号使用统计
	SymbolCallUses map[Ref]SymbolCallUse // 作为函数调用的符号统计
	ImportSymbolPropertyUses map[Ref]map[string]SymbolUse // 记录了导入符号的使用，因为解释过程中并不知道导入符号的使用情况，必须在link阶段才可以知道
	Dependencies []Dependency // 其他part依赖
	CanBeRemovedIfUnused bool // 标记是否有副作用
	ForceTreeShaking bool // 哪个全局的tree shaking没有开启，只要这个标记打开也会启动tree shaking
	IsLive bool // 是否为live，主要用tree shaking阶段
}

# 杂七杂八
用位掩码来记录每个entry有没有访问过，
后面就可以用来提取公共代码

## 寻找css引用文件
js深度遍历导入的引用
然后后序排序
但是动态导入是不可预料的加载时机的

## tree shaking
tree shaking没开启那就一个文件只有一个part，如果开始所有top level语句都是一个part


## allocateSourceIndex
scanner每次build都会重新构建，但是会把之前的解释的缓存回传回去
scanner的results就是每次扫描所有文件后的解析的结果

scanner会维护一个cache，以路径为索引->sourceIndex

然后scanner的results 就是根据sourceIndex自动调整的slice

也就是说这个results可能会很长，缓存很多文件parseResults

但是sourceIndex是确定的

# js引用的不同类型的文件
AST.HasLazyExport 会标记为true
并且产生SLazyExport语句
part := js_ast.Part{
	Stmts:      []js_ast.Stmt{{Loc: expr.Loc, Data: &js_ast.SLazyExport{Value: expr}}},
	SymbolUses: p.symbolUses,
}
## json
对于json，会变成js里面的一个对象

## css
对于css，会转变成js类型的解释结果，
graph.JSRepr的CSSSourceIndex会被设置
要在linker阶段独立处理

## 其他
其他文件都是当成js里面的一个字符处理

# 关于增量更新设计

# ESPack改造
Step 1
1. 增加webpack运行时 // 模仿原本runtime 添加一个webpack_rutime模块 done
2. 增加hot-reload通知能力 // done
3. 增加ast-tranform能力 // 这个看来是不需要的，因为已经把信息提取到
4. 增加css-loader处理逻辑 // done
5. 增加react-hot-loader处理逻辑 // done 
6. sass-loader // done
目标：能够使用espack跑起项目 // done

Step 2
1. 重构js_ast遍历
2. 优化增量更新逻辑，目标在200ms
3. 使用fsnotify替换原本的watcher
4. ejs插件
5. source_map // doing
6. tree shaking效果对比
7. stream link降低开发时内存消耗 // doing
目标：能够使用espack开发项目

Step 3
1. 添加code-spliting算法模块，能够基于请求数或者文件大小来分块
2. async chunk处理
目标：能够使用espack进行打包

Step 4
1. 添加打包数据输出
2. 新的数据分析页面
目标：能够高效分析页面模块依赖关系


